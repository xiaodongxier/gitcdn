<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>æ—¶é—´é”</title>
  <base target="_blank">
  <style>
    body, input {
      font-family: monospace;
      font-size: 15px;
    }
    input {
      width: 20em;
    }
    #txtPlain, #txtCipher {
      width: 100%;
      height: 5em;
    }
    #progressBar {
      width: 20em;
    }
    #txtError {
      height: 1em;
      color: red;
    }
  </style>
</head>
<body>
  <div>ğŸ‘ æ˜æ–‡:</div>
  <div>
    <textarea id="txtPlain"></textarea>
  </div>
  <div>
    ğŸ”‘ å¯†é’¥: <input id="txtKey" type="text">
    <button id="btnGenKey">ğŸ² éšæœºç”Ÿæˆ</button>
  </div>
  <div>
    â° éš¾åº¦: <input id="txtIter" type="number" value="10" min="1">
  </div>
  <div>
    â³ è¿›åº¦: <progress id="progressBar" value="0" max="100"></progress>
    <span id="txtProgVal"></span>/<span id="txtProgMax"></span>
    (<span id="txtProgPercent"></span>%)
    å‰©ä½™æ—¶é—´ <span id="txtTime">-</span>
  </div>
  <div>
    <button id="btnEncrypt">ğŸ”½ åŠ å¯†</button>
    <button id="btnDecrypt">ğŸ”¼ è§£å¯†</button>
    <button id="btnPause">â¸ï¸ æš‚åœ</button>
    <button id="btnResume">â¯ï¸ ç»§ç»­</button>
    <button id="btnStop">â¹ï¸ åœæ­¢</button>
    <button id="btnShare">ğŸ”— åˆ†äº«</button>
  </div>
  <div>ğŸ” å¯†æ–‡:</div>
  <div>
    <textarea id="txtCipher"></textarea>
  </div>
  <div>
    <div id="txtError"></div>
  </div>
  <p>ğŸ’¡ æç¤º:</p>
  <p>
    å‘é€è€…å¯¹æ˜æ–‡è¿›è¡ŒåŠ å¯†ï¼Œéš¾åº¦è¶Šå¤§è§£å¯†è¶Šæ…¢ï¼Œè¿«ä½¿æ¥æ”¶è€…å¿…é¡»ç»è¿‡ä¸€å®šæ—¶é—´æ‰èƒ½è§£å¼€å¯†æ–‡ã€‚ç›®å‰ä¸»æµ CPU æ¯ 1 éš¾åº¦ç”¨æ—¶å¤§çº¦ 1 ç§’ã€‚
  </p>
  <p>
    æœ¬ç¨‹åºèƒ½è€—å¤§ï¼Œä¸å»ºè®®åœ¨ç§»åŠ¨ç«¯è¿è¡Œã€‚PC ç«¯å»ºè®®ä½¿ç”¨ Chromeï¼Œæ€§èƒ½æ›´é«˜ã€‚å¦‚æœé¡µé¢è¢«æš‚åœè¿è¡Œï¼Œå¯å°è¯•æ”¾åœ¨å•ç‹¬çš„çª—å£ä¸­ã€‚
  </p>
  <p>
    å¦‚ä½•åŠ é€Ÿè§£å¯†ï¼Ÿå•æ ¸æ€§èƒ½è¶Šé«˜ï¼Œè§£å¯†é€Ÿåº¦è¶Šå¿«ã€‚å¤šæ ¸æˆ–æ˜¾å¡æ€§èƒ½å¯¹è§£å¯†é€Ÿåº¦æ— æå‡ã€‚å¦‚æœç”¨ FPGA ç”šè‡³ä¸“ç”¨èŠ¯ç‰‡è§£å¯†ï¼Œé€Ÿåº¦è¿˜èƒ½å¤§å¹…æå‡ã€‚
  </p>
  <p>
    èƒ½å¦ç¬é—´åŠ å¯†ï¼Ÿç†è®ºä¸Šå¯ä»¥ï¼Œå‚è€ƒ[<a href="https://people.csail.mit.edu/rivest/pubs/RSW96.pdf">è¿™ç¯‡è®ºæ–‡</a>]ï¼Œä½†æµè§ˆå™¨æœªæä¾›ç›¸å…³ APIï¼Œå³ä½¿é€šè¿‡ WebAssembly å®ç°ï¼Œè§£å¯†æ€§èƒ½ä»æ¯”è¢«åŸç”Ÿä½å¾ˆå¤šï¼Œæ²¡æœ‰å¿…è¦åœ¨ç½‘é¡µä¸­è§£å¯†ã€‚å› æ­¤æœ¬ç¨‹åºä½¿ç”¨æµè§ˆå™¨å†…ç½®çš„ PBKDF2 ä½œä¸ºå»¶æ—¶å‡½æ•°ï¼Œé¿å…é¢å¤–å¼€é”€ï¼Œä½†ç¼ºç‚¹æ˜¯åŠ å¯†å’Œè§£å¯†ä¸€æ ·æ…¢ã€‚å½“ç„¶å®é™…åº”ç”¨æ—¶å¯ç¦»çº¿è®¡ç®—ï¼Œé¢„å…ˆç”Ÿæˆå¯†é’¥æ± ï¼Œä¹Ÿå¯è¾¾åˆ°ç¬é—´åŠ å¯†çš„æ•ˆæœã€‚
  </p>
  <script type="module">
    // Vanilla JS
    const {subtle} = crypto

    async function pbkdf2(pwd, opts, bits) {
      const baseKey = await subtle.importKey('raw', pwd, 'PBKDF2', false, ['deriveBits'])
      return await subtle.deriveBits(opts, baseKey, bits)
    }

    async function aesEncrypt(plain, key, iv) {
      const baseKey = await subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt'])
      const buf = await subtle.encrypt({name: 'AES-GCM', iv}, baseKey, plain)
      return new Uint8Array(buf)
    }

    async function aesDecrypt(cipher, key, iv) {
      const baseKey = await subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt'])
      const buf = await subtle.decrypt({name: 'AES-GCM', iv}, baseKey, cipher)
      return new Uint8Array(buf)
    }

    function str2bin(str) {
      return new TextEncoder().encode(str)
    }

    function bin2str(bin) {
      return new TextDecoder().decode(bin)
    }

    function hex2bin(str) {
      const hex = str.trim().match(/^0x((?:[0-9A-F]{2})+)$/i)?.[1]
      if (!hex) {
        return
      }
      const bin = new Uint8Array(hex.length / 2)
      for (let i = 0; i < hex.length; i += 2) {
        bin[i / 2] = parseInt(hex[i] + hex[i + 1], 16)
      }
      return bin
    }

    function bin2hex(bin) {
      const hex = [...bin]
        .map(v => v.toString(16).padStart(2, '0'))
        .join('')
      return '0x' + hex.toUpperCase()
    }

    function createSignal() {
      let callback
      const promise = new Promise(resolve => {
        callback = resolve
      })
      promise.notify = callback
      return promise
    }

    function formatTime(sec) {
      const time = new Date(sec * 1000).toISOString().slice(11, 19)
      const day = sec / 86400 | 0
      if (day) {
        return `${day}å¤©${time}`
      }
      return time
    }

    btnGenKey.onclick = function() {
      const bin = crypto.getRandomValues(new Uint8Array(8))
      txtKey.value = bin2hex(bin)
    }

    let isStopped = true
    let pausedSignal

    async function computeKey() {
      let keyBin = hex2bin(txtKey.value)
      if (!keyBin) {
        showError('æ— æ•ˆçš„å¯†é’¥')
        return
      }
      showError('')

      const pbkdfOpts = {
        name: 'PBKDF2',
        hash: 'SHA-256',
        salt: new Uint8Array(0),
        iterations: 1e7,
      }
      const iterNum = +txtIter.value
      isStopped = false
      txtTime.textContent = 'è¯„ä¼°ä¸­...'

      //
      // ç”±äº PBKDF2 ä¸æ”¯æŒå›è°ƒï¼Œå› æ­¤æ— æ³•æŸ¥çœ‹è¿›åº¦
      // æ­¤å¤–è¿­ä»£æ¬¡æ•°æœ‰ä¸Šé™ï¼Œå› æ­¤æ— æ³•é•¿æ—¶é—´è¿è¡Œ
      // æœ¬ç¨‹åºé€šè¿‡å¤šæ¬¡è°ƒç”¨ PBKDF2 çš„æ–¹å¼è§„é¿è¿™äº›é—®é¢˜
      //
      for (let i = 1; i <= iterNum; i++) {
        const t0 = Date.now()
        keyBin = await pbkdf2(keyBin, pbkdfOpts, 256)
        const t1 = Date.now()

        const elapsedSec = (t1 - t0) / 1000
        const remainIter = iterNum - i
        txtTime.textContent = formatTime(Math.ceil(remainIter * elapsedSec))

        updateProgress(i, iterNum)

        if (pausedSignal) {
          showError('è®¡ç®—æš‚åœ')
          await pausedSignal
          showError('')
        }
        if (isStopped) {
          updateProgress(0, iterNum)
          showError('è®¡ç®—ç»ˆæ­¢')
          keyBin = undefined
          break
        }
      }

      txtTime.textContent = '-'
      isStopped = true
      return keyBin
    }

    btnEncrypt.onclick = async function() {
      if (!isStopped) {
        return
      }
      const plain = str2bin(txtPlain.value)
      if (plain.length === 0) {
        showError('æ˜æ–‡ä¸ºç©º')
        return
      }
      txtCipher.value = ''
      updateButtonState()

      const key = await computeKey()
      if (!key) {
        return
      }
      const cipher = await aesEncrypt(plain, key, new Uint8Array(16))
      txtCipher.value = bin2hex(cipher)
    }

    btnDecrypt.onclick = async function() {
      if (!isStopped) {
        return
      }
      const cipher = hex2bin(txtCipher.value)
      if (!cipher) {
        showError('æ— æ•ˆçš„å¯†æ–‡')
        return
      }
      txtPlain.value = ''
      updateButtonState()

      const key = await computeKey()
      if (!key) {
        return
      }
      try {
        const plain = await aesDecrypt(cipher, key, new Uint8Array(16))
        txtPlain.value = bin2str(plain)
      } catch (err) {
        showError('è§£å¯†å¤±è´¥')
      }
    }

    btnPause.onclick = function() {
      if (isStopped) {
        return
      }
      if (pausedSignal) {
        return
      }
      pausedSignal = createSignal()
    }

    btnResume.onclick = function() {
      if (!pausedSignal) {
        return
      }
      pausedSignal.notify()
      pausedSignal = undefined
    }

    btnStop.onclick = function() {
      if (isStopped) {
        return
      }
      if (confirm('ç¡®å®šåœæ­¢?')) {
        btnResume.onclick()
        isStopped = true
      }
    }

    btnShare.onclick = function() {
      const url = new URL(location.href)
      url.hash = new URLSearchParams({
        'iter': txtIter.value,
        'key': txtKey.value,
        'cipher': txtCipher.value,
      })
      navigator.clipboard.writeText(url)
      alert('å¯†æ–‡é“¾æ¥å·²å¤åˆ¶')
    }

    function updateProgress(val, max) {
      const percent = (val / max) * 100
      progressBar.value = percent

      txtProgPercent.textContent = percent.toFixed(2)
      txtProgMax.textContent = max
      txtProgVal.textContent = val
    }

    function updateButtonState() {
      btnEncrypt.disabled = !txtPlain.value
      btnDecrypt.disabled = !txtCipher.value
    }

    function showError(msg) {
      txtError.textContent = msg
    }

    window.onbeforeunload = function() {
      if (!isStopped) {
        return 'æ­£åœ¨è®¡ç®—ä¸­ï¼Œæ˜¯å¦ç¦»å¼€'
      }
    }

    txtPlain.oninput = txtCipher.oninput = updateButtonState

    function updateParams() {
      const params = new URLSearchParams(location.hash.substring(1))
      const KEY_TEXTBOX_MAP = {
        'key': txtKey,
        'iter': txtIter,
        'plain': txtPlain,
        'cipher': txtCipher,
      }
      for (const [k, v] of Object.entries(KEY_TEXTBOX_MAP)) {
        if (params.has(k)) {
          v.value = params.get(k)
        }
      }
      updateButtonState()
    }
    window.onhashchange = updateParams


    function main() {
      updateParams()
      updateProgress(0, +txtIter.value)

      if (!isSecureContext) {
        showError('æœ¬ç¨‹åºå¿…é¡»ä½äº HTTPS æˆ–æœ¬åœ°ç«™ç‚¹')
      }
    }
    main()
  </script>
</body>
</html>